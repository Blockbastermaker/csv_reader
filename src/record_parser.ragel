// vi:syntax=ragel

#ifndef _CSV_RECORD_PARSER_H_
#define _CSV_RECORD_PARSER_H_

#include <iostream>
#include <string>
#include <algorithm>


namespace csv {

  %%{
    machine csv_record_parser;

    action reset_val {
      this->ts = p;
      this->te = p;
    }

    action inc_val {
      this->te++;
    }

    action finish_field {
      try {
        fields.at(current_field).erase();
        fields[current_field].append(ts, te - ts);
      } catch(const std::out_of_range&) {
        fields.push_back(std::string(ts, te-ts));
      }
      current_field++;
    }

    action finish_record {
      this->finished = true;
    }

    quoted_field = space* '"' <: ([^"] | '""')** :> '"' space*;
    unquoted_field = (any - ',' - '\n' - '"')** ;
    field = (quoted_field | unquoted_field) >reset_val $inc_val %finish_field;
    main := field (',' field)* '\n' $finish_record;
  }%%

  %% write data;

  class RecordParser {
    public:
      RecordParser() {}

      // returns current position in buffer...
      const char* parse(const char *begin, const char *end, std::vector<std::string> &fields) {
        // initialize read pointer
        %% write init;

        this->p = begin;
        this->pe = end;
        this->finished = false;
        size_t current_field = 0;

        %% write exec;

        if(!this->finished) {
          // TODO: throw exception
          std::cout << "ERROR" << std::endl;
        } else {
          this->_cleanFields(fields);
        }

        return p;
      }

    private:

      void _cleanFields(std::vector<std::string> &fields) {
        for(auto &field : fields) {
        }
      }

      // no write data, we do that manually
      const char *p, *pe, *eof;
      const char *ts, *te;
      int act, cs, top, stack[1];

      bool finished;
  };
}

#endif
